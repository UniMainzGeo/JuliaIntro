[{"url":"Basic_Operations/","title":"Basic mathematics","tags":["Basics"],"text":" A Pluto.jl notebook v0.19.25 frontmatter Authors \"Pascal Aellig\" title \"Basic mathematics\" tags \"Basics\" license \"MIT\" description \"This is the first step towards programming in Julia\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils begin using Colors, ColorVectorSpace, ImageShow, FileIO, ImageIO using PlutoUI using PlutoTeachingTools using Printf using HypertextLiteral using WGLMakie using Plots end md\" Basic Julia operations and plotting\" md\"In this notebook you will learn how Julia calculates and start plotting your own function Do to this online environment, some things are different than in VS Code. For example Rather than overwriting a variable, it disables the cell above. So be advised to give a new name when computing. Multi line codes that are not a function must have begin your lines end to ensure Pluto runs it correctly. Otherwise you can always split the cells\" md\" 1. Basic operations Julia is a scientific programming language, which means that it is designed to be used for mathematical operations. Try out the following operations \" 1 1 try for yourself 3 4 12 4 3^2 md\"Powers are performed before divisions and multiplications, which are done before subtraction and addition\" 2 4 5^2 md\"In VS Code you can also use the 'command line editiing' tool that allows you to go up and down with the keyboard arrows. Which can safe quite some time for long calculations, such as above\" 2 4 5^2 2 md\" In Julia use the equal sign to assign values to variables. This should be known from other programming languages.\" x 1 1 md\"To find out what the type of a certain variable is, type \" typeof x md\"What type will you get for x if it has decimals?\" a 2.1 typeof a md\"The cool part about this Pluto notebook is that if you change a variable, it automatically updates the cells below. Try it for yourself\" c 10 md\"Update `c` accordingly to get b 1000\" b c 100 if b 1000 correct md\"Nice, now move on to vektors\" else keep working end md\" 2. Vectors\" md\" Until now you've dealt with scalar values. Now its time to work on Vectors\" m 0 .1 2 md\"If you want to retrieve a specific value of the vector, lets say the third 3. do it like this \" m 3 md\"Julia arrays start at 1\" m 1 md\"You can now do some random calculations with x as we did with b with the scalars.\" y m.^2 . 1 md\"Note the dot . here, which tells julia that every entry of x should be squared and 1 is added. If you want a vector with values, they should be separated by commas \" k 1.2, 3, 5, 6 md\" 3 Matrixes\" md\"A matrix in julia can be defined as \" n 1 2 3 4 5 6 md\"Note that the elements of a matrix being entered are enclosed by brackets a matrix is entered in ‚Äúrow major order‚Äù i.e. all of the first row, then all of the second row, etc rows are separated by a semicolon or a newline , and the elements of the row should be separated by a space. The element in the i‚Äôth row and j‚Äôth column of a is referred to in the usual way \" n 1,2 md\"The transpose of a matrix is the result of interchanging rows and columns. Julia denotes the transpose by folowing the matrix with the single quote apostrophe .\" n' md\"New matrices may be formed out of old ones, in many ways.\" r n 7 8 9 n n n n n n md\"There are many built. in matrix constructions. Here are a few \" rand 1,3 rand 2 zeros 3 ones 3,2 md\"Use a semicolon to suppress output within the REPL \" s zeros 20,30 md\"This is useful, when working with large matrices. An often used part of Julia is the ‚Äòcolon operator,‚Äô which produces a list.\" 3 3 md\"The default increment is by 1, but that can be changed.\" q 3 .4 3 md\"This can be read x is the name of the list, which begins at 3 with a constant increase of 0.4 until it reaches and surpasses 3. You can think of x as a list, a vector, or a matrix, its up to you. If you'd like, you can even use this to extract 'subvectors', as follows.\" q 4 8 q 9 2 1 u 10 100 u 40 5 60 md\"The colon notation can also be combined with the earlier method of constructing matrices.\" g 1 6 2 7 4 9 md\"The colon notation can also be combined with the earlier method of constructing matrices.\" xx 1 6 2 7 4 9 md\"A very common use of the colon notation is to extract rows, or columns, as a sort of ‚Äúwild card‚Äù operator which produces a default list. The following command demonstrates this\" yy rand 10,5 s 6 7,2 4 md\"Matrices may also be constructed by programming. Here is an example, creating a ‚Äòprogram loop.‚Äô, which shows how\" A i j for i 1 10,j 1 11 md\"Notice how you can add multiple for statements of variables into one for loop? Cool right?\" correct md\"You made it, already halfway\" md\" 4. Matrix arithmetic\" begin a2 1 2 3 4 5 6 7 8 10 b2 1 1 1 ' end md\"Scalars multiply matrices as expected, and matrices may be added in the usual way both are done ‚Äôelement by element.‚Äô\" 2 a2, a2 4 md\"Scalars added to matrices require you to add a dot, as\" a2. 1 md\"Matrix multiplication requires that the sizes match. If they don‚Äôt, an error message is generated.\" a2 b2 a2 b2' md\"A matrix matrix multiplication is done with \" a2 a2 md\"whereas adding a dot performs a pointwise multiplication \" a2. a2 correct md\"Nice Now lets plot and visualise something\" md\" 5. Plotting\" md\" 5.1 Adding plotting packages As you already learned in the installation guide, Julia has an internal package manager, where you can add different packages. Now we want to plot something, therefore we need Plots.jl or Makie.jl ```julia julia v1.9 pkg add Plots, Makie ``` Once the installation is done, you can test whether the package works by running the build in testing suite of that package which is available for most julia packages . When running it from VS Code, this can take a looong time, depending on your machine. If you get impatient, you can stop this with CTRL C. Once you are done with the package manager, go back to the REPL with the backspace button. However as we now run it on a Pluto notebook, we have already set it up. That's the reason why it took so long to load at the beginning. \" md\" 3.2 Plotting Now lets create our first plot ```julia julia plot x,y ```\" t 0 .1 2 w t.^2 . 1 plot t,w, xlabel \"x\", ylabel \"y axis\", title \"my first plot\",label none, color red almost md\"Oops, we are currently using two packages that have a function called `plot `. You need to specify which one you want by `Plots.plot ` \" Plots.plot t,w, xlabel \"x\", ylabel \"y axis\", title \"my first plot\",label none, color red md\"There are lots of options within the plotting package. Have a look at the tutorial here https docs.juliaplots.org latest . If you are used to work with MATLAB Octave, here a quick summary of how plotting options are called in the Plots.jl package of julia MATLAB | Julia | plot x,y,‚Äòr‚Äì‚Äô | plot x,y,linestyle dash, color red scatter x,y | scatter x,y mesh x,y,z | wireframe x,y,z surf x,y,z | plot x,y,z,st surface pcolor x,y,z | heatmap x,y,z contour x,y,z,50 | contour x,y,z,level 50 contourf x,y,z | contour x,y,z,level 50,fill true \" md\" 7. Functions\" f x x.^2 . 10 md\"You can now use this function with scalars, vectors or arrays \" f 10 l 1 3 f l p 1 2 3 4 f p md\"Functions of course don‚Äôt have to be one liners, so you can also define it as \" function f1 x y x.^2 . 11 return y end x3 1 1e6 md\"It turns out that julia has a handy macro, called ` time`, with which you can record the time that a function took.\" time f1 x3 md\"As you can see, the function runs super quick. That's because the code is precompiled and only needs to run the function, which creates 2 allocations. Also note that you need to restart the REPL on VS Code or your Julia session every time you redefine a function or a structure.\" md\" 8. Scripts\" md\"In general, you want to put your code in a julia script so you don‚Äôt have to type it always in the REPL. Doing that is simple you simple save it as a textfile that had has .jl as an ending. Note When working in scripts you need to state what packages you want to use at the beginning with `using Plots` etc. A simple example is the following script \" begin function rosenbrock x,y a 1,b 100 xt x' transpose f a . xt .^2 . b. y . xt.^2 .^2 return f end x5 range 2.0,2.0,length 50 y5 range 1.0,1.5,length 50 t1 rosenbrock x5,y5 Create a contourplot Plots.contour x5,y5,t1, levels 0 10 200, fill true, xlabel \"X\", ylabel \"y\", title \"rosenbrock\", color roma, clim 1,200 end md\"Note that the rosenbrock function has optional parameters a,b . Calling it with only X,Y will invoke the default parameters, but you can specify the optional ones with f rosenbrock x,y, b 200,a 3 . You can save this as a script and run it in the julia REPL in the following way \" md\"`include ` Note Within the Parantheses, there must be quotation marks \" md\"Be aware that you need to be in the same directory as the script see below on how you can change directories using the build in shell in julia, by typing in the REPL . The result looks like have a look at how we customized the colormap, and added info for the axes .\" md\" 9. Help\" md\"In general, you can get help for every function by typing `?` which brings you to the help terminal. Next type the name of the function. For example, lets find out how to compute the average of an array ```julia julia ?mean ``` You can add help info to your own functions by adding comments before the function, using quotation marks.\" \"\"\" y f2 withhelp x Computes the square of `x` and adds 10 Example julia x 1 10 julia y f2 withhelp x 10 element Vector Int64 11 14 19 26 35 46 59 74 91 110 \"\"\" function f2 withhelp x y x.^2 . 10 return y end md\" 9.1 Built in terminal\" md\"Julia has a built in terminal, which you can reach by typing . This comes in handy if you want to check in which directory you are, change directories, or look at the files there. ```julia julia shell pwd Users kausb ``` Note that this invokes the default terminal on your operating system, so under windows the commands are a but different than under linux. Once you are done with the terminal, you get back to the REPL, by using the backspace. 9.2 Online help The official julia manual https docs.julialang.org en v1 is a good place to start. Many of the julia packages are hosted on github and have help pages as well. An example, which we will use here, is GeophysicalModelGenerator.jl https github.com JuliaGeodynamics GeophysicalModelGenerator.jl` .\" TableOfContents title \"Introduction to Julia by AG Geophysik at the University of Mainz\", indent true, depth 4, aside true "},{"url":"Diffusion2D/","title":"Diffusion 2D","tags":["bcn"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"2\" Authors \"Ludovic R√§ss, Ivan Utkin\" section \"1.5\" order \"1.5\" title \"Diffusion 2D\" tags \"bcn\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils begin using Plots, Printf using Plots.PlotMeasures end begin views av A 0.5 . A 1 end 1 . A 2 end macro avy A esc 0.5 A iy, iz A iy 1, iz end macro avz A esc 0.5 A iy, iz A iy, iz 1 end macro av4 A esc 0.25 A iy, iz A iy, iz 1 A iy 1, iz A iy 1, iz 1 end macro d ya A esc A iy 1, iz A iy, iz end macro d za A esc A iy, iz 1 A iy, iz end macro d yi A esc A iy 1, iz 1 A iy, iz 1 end macro d zi A esc A iy 1, iz 1 A iy 1, iz end end function update q ?? Threads. threads for iz 1 size C, 2 for iy 1 size C, 1 if iy ?? && iz ?? qy iy, iz ?? end if iy ?? && iz ?? qz iy, iz ?? end end end return end function update C ?? Threads. threads for iz 1 size C, 2 for iy 1 size C, 1 ?? end end return end views function main physics ly, lz 1.0, 1.0 d0 1.0 numerics nz 128 ny ceil Int, nz ly lz cfl 1 4.1 maxiter 200 ncheck 20 preprocessing dy, dz ly ny, lz nz yc, zc LinRange ly 2 dy 2, ly 2 dy 2, ny , LinRange dz 2, lz dz 2, nz dœÑ cfl min dy, dz ^2 init C . exp yc^2 0.02 zc' lz 2 ^2 0.02 D d0 . ones ny 1, nz 1 qy zeros ny 1, nz 2 qz zeros ny 2, nz 1 action iters evo Float64 errs evo Float64 iter 1 while iter maxiter ?? ?? if iter % ncheck 0 err maximum C push iters evo, iter nz push errs evo, err p1 heatmap yc, zc, C' aspect ratio 1, xlabel \"y\", ylabel \"z\", title \"C\", xlims ly 2, ly 2 , ylims 0, lz , c turbo, clims 0, 1 , right margin 10mm p2 plot iters evo, errs evo xlabel \"niter\", ylabel \"max C \", yscale log10, framestyle box, legend false, markershape circle display plot p1, p2 size 800, 400 , layout 1, 2 , bottom margin 10mm, left margin 10mm printf \" iter %.1f, max C %1.3e\\n\", iter, err end iter 1 end return end main "},{"url":"GMG_Importing_Data/","title":"Importing Data","tags":["GMG","lecture"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"1\" Authors \"Pascal Aellig\" title \"Importing Data\" section \"2\" order \"2\" tags \"GMG\", \"lecture\" layout \"layout.jlhtml\" description \"Importing Data\" License \"MIT\" using Markdown using InteractiveUtils md\" Importing Data DISCLAIMER THIS PART IS TAKEN FROM THE GMG TUTORIAL OF M.THIELMANN UNI BAYREUTH 1. Data sources Before you can use GMG, you obviously need data. Given the different kinds of data available, there is a multitude of sources. Here, we list some of them that may be useful in the future MB4D Data Repository https dataservices.gfz potsdam.de 4dmb Repository for data obtained within SPP 4DMB ETOPO1 https www.ncei.noaa.gov products etopo global relief model Global relief data with a resolution of 1 arc minute IRIS Earth Model Collaboration http ds.iris.edu ds products emc earthmodels Different Earth Models, in particular a large collection of seismic tomographies our own database https seafile.rlp.net d 22b0fb85550240758552 a collection of different data which we have already processed with GMG and many more‚Ä¶ A lot of data is also not available via dedicated repositories, but via more general repositories such as Zenodo or even hosted on private websites. For the purpose of this tutorial, we will now focus on data from seismic tomographies. For the European Alps, there are several datasets which are freely available. Here, we will use the dataset by Paffrath et al. which uses AlpArray data. The data is available for download in a public repository https doi.org 10.5880 fidgeo.2021.032 Paffrath, M., Friederich, W., and the AlpArray and AlpArray Swath D working group Imaging structure and geometry of slabs in the greater Alpine area ‚Äì A P wave traveltime tomography using AlpArray Seismic Network data, Solid Earth Discuss., https doi.org 10.5194 se 12 2671 2021 https doi.org 10.5194 se 12 2671 2021 , 2021.\" md\" 2. Importing tomographic data given as ASCII file\" "},{"url":"GMG_Package_description/","title":"Package Description","tags":["GMG","lecture"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"1\" Authors \"Pascal Aellig\" section \"1\" order \"1\" title \"Package Description\" tags \"GMG\", \"lecture\" layout \"layout.jlhtml\" description \"Geophysical Model Generator\" License \"MIT\" using Markdown using InteractiveUtils md\" Package Description 1. What is the Geophysical Model Generator? The idea for the Geophysical Model Generator was born out of the need to view different geophysical datasets e.g. tomographies, gravity measurements, receiver functions and others in a single joint manner without having to resort to specifically programmed visualization routines for each case. The Geophysical Model Generator is NOT a single program, but can rather be seen as a set of tools written in julia that allow to import and modify different datasets and transfer them to a common data structure. This common data structure then allows to process and visualize the different datasets in a coherent manner, thus facilitating comparisons and interpretations. In addition, the GMG provides tools to assist numerical modellers in creating input models from these datasets. For this, the julia module GeophysicalModelGenerator.jl provides the following functionality A consistent GeoData structure, that holds the data along with lon lat depth information. Routines to generate VTK files from the GeoData structure in order to visualize results in Paraview. The ability to deal with points, 2D profiles and 3D volumes, for both scalar and vector values. Rapidly import screenshots of published papers compare them with other data sets in 3D using paraview. Create geodynamic input models for LaMEM 2. Installation To install GeophysicalModelGenerator.jl, start julia and go to the package manager ```julia julia v1.9 pkg add GeophysicalModelGenerator ``` This will automatically install various other packages it relies on using the correct version . If you want, you can test if it works on your machine by running the test suite in the package manager ```julia julia v1.9 pkg test GeophysicalModelGenerator ``` Note that we run these tests automatically on Windows, Linux and Mac every time we add a new feature to GeophysicalModelGenerator using different julia versions . This Continuous Integration CI ensures that new features do not break others in the package. The results can be seen here. The installation of GMG only needs to be done once, and will precompile the package and all other dependencies. If you, at a later stage, want to upgrade to the latest version of GMG, you can type ```julia julia v1.9 pkg update GeophysicalModelGenerator ``` You can load GeophysicalModelGenerator, for example to create cross sections, with ```julia julia using GeophysicalModelGenerator ``` 3. Dependencies We rely on a number of additional packages. All of them are automatically installed, except GeoParams.jl, which you currenty have to add yourself, again using the package manager. GeoParams.jl https github.com JuliaGeodynamics GeoParams.jl Defines dimensional units, and makes it easy to convert for km s to m s, etc. WriteVTK.jl https github.com JuliaVTK WriteVTK.jl writes VTK files to be opened with Paraview . ImageIO.jl https github.com JuliaIO ImageIO.jl , FileIO.jl https github.com JuliaIO FileIO.jl , Colors.jl https github.com JuliaGraphics Colors.jl to import screenshots from papers. Interpolations.jl https github.com JuliaMath Interpolations.jl for interpolations for example related to importing screenshots .\" "},{"url":"GMT/","title":"Exercise of GMG","tags":["GMG","lecture"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"1\" Authors \"Pascal Aellig\" section \"3\" order \"3\" title \"Exercise of GMG\" tags \"GMG\", \"lecture\" license \"MIT\" description \"This is the first step towards programming in Julia\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils begin using Colors, ColorVectorSpace, ImageShow, FileIO, ImageIO using PlutoUI using PlutoTeachingTools using Printf using HypertextLiteral end begin using GMT using GeophysicalModelGenerator using WGLMakie end md\" UNSTABLE Test of GMG with GMT in Pluto WIP \" md\" DISCLAIMER This webpage is a work in progress and if you got recommendations, feel free to email us mailto paellig uni mainz.de \\ Furthermore, this Introduction was inspired by the MIT Computational Thinking class and Marcel Thielmanns's course on the Geophysical Model Generator Uni Bayreuth\" Topo ImportTopo lon 18.7, 17.1 , lat 28.0, 29.2 , file \" earth relief 03s.grd\" begin xs range 0, 10, length 25 ys range 0, 15, length 25 zs cos x sin y for x in xs, y in ys heatmap xs, ys, zs end begin N 60 function xy data x, y r sqrt x^2 y^2 r 0.0 ? 1f0 sin r r end l range 10, stop 10, length N z Float32 xy data x, y for x in l, y in l WGLMakie.surface 1..1, 1..1, z, colormap Spectral end begin proj ProjectionPoint Lat 28.6, Lon 342.1 Topo Cart Convert2CartData Topo, proj end Nx,Ny,Nz 100,100,100 begin Grid CreateCartGrid size Nx,Ny,Nz , x Topo Cart.x.val, y Topo Cart.y.val, z Topo Cart.z.val X,Y,Z XYZGrid Grid.coord1D... end X WGLMakie.heatmap X,Y,Z, colorbar roma begin zmin, zmax minimum Z , maximum Z cmap oleron fig Figure resolution 1200, 800 , fontsize 22 ax Axis3 fig 1, 1 , aspect data, perspectiveness 0.5, elevation œÄ 9, zgridcolor grey, ygridcolor grey, xgridcolor grey sm WGLMakie.surface ax, X, Y, Z colormap cmap, colorrange zmin, zmax , transparency true xm, ym, zm minimum ax.finallimits WGLMakie.contour ax, x, y, z levels 20, colormap cmap, linewidth 2, colorrange zmin, zmax , transformation xy, zmin , transparency true wireframe ax, x, y, z overdraw true, transparency true, color black, 0.1 Colorbar fig 1, 2 , sm, height Relative 0.5 colsize fig.layout, 1, Aspect 1, 1.0 fig end App do session Session n 10 index slider Slider 1 n volume rand n, n, n slice map index slider do idx return volume , , idx end fig Figure ax, cplot contour fig 1, 1 , volume rectplot linesegments ax, Rect 1, 1, 12, 12 , linewidth 2, color red on index slider do idx translate rectplot, 0,0,idx end heatmap fig 1, 2 , slice slider DOM.div \"z index \", index slider, index slider.value return JSServe.record states session, DOM.div slider, fig end "},{"url":"ReadMe_BCN_MC23/","title":"MasterClass 2023 ","tags":["bcn","lecture"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"2\" Authors \"Ludovic R√§ss, Ivan Utkin\" section \"1\" order \"1\" title \"MasterClass 2023 \" tags \"bcn\", \"lecture\" layout \"layout.jlhtml\" description \"Workshop of the MC23 in BCN\" using Markdown using InteractiveUtils md\" Galileo23 Master class 1 GPU HPC in Julia Solid Earth and Geohazards in the Exascale Era | BARCELONA | SPAIN | 23‚Äì26 MAY 2023 https egu galileo.eu gc11 solidearth Master class on GPU HPC for the exascale era in geosciences by Ludovic R√§ss and Ivan Utkin ETH Zurich üëÄ ATTENTION The content was just updated, make sure to `git pull` before getting started Content Slot 1 Intro slot 1 Slot 2 Hands on I slot 2 Slot 3 Hands on II slot 3 Slot 4 OPTION 1 slot 4 Slot 1 Getting started This section provides directions on getting your GPU HPC dev environment ready on the `octopus` supercomputer at the University of Lausanne, Switzerland. During this Master class, we will use SSH to login to a remote multi GPU compute node on `octopus`. Each of the participant should get access to 4 Nvidia Titan Xm 12GB. Useful resources The Julia language https julialang.org https julialang.org PDE on GPUs ETH Zurich course https pde on gpu.vaw.ethz.ch https pde on gpu.vaw.ethz.ch Julia Discourse Julia Q&A https discourse.julialang.org https discourse.julialang.org Julia Slack Julia dev chat https julialang.org slack https julialang.org slack Julia and HPC Some words on the Julia at scale effort, the Julia HPC packages, and the overall Julia for HPC motivation two language barrier The yet invisible cool stuff Today, we will develop code that Runs on graphics cards using the Julia language Uses a fully local and iterative approach scalability Retrieves automatically the Jacobian Vector Product JVP using automatic differentiation AD All scripts feature less than 400 lines of code Too good to be true? Hold on üôÇ ... Why to still bother with GPU computing in 2023 It's around for more than a decade It shows massive performance gain compared to serial CPU computing First exascale supercomputer, Frontier, is full of GPUs Frontier assets bcn frontier.png badge Performance that matters cpu gpu evo assets bcn cpu gpu evo.png badge Taking a look at a recent GPU and CPU Nvidia Tesla A100 GPU Nvidia Titan Xm GPU AMD EPYC 'Rome' 7282 16 cores CPU | Device | TFLOP s FP64 | Memory BW TB s | Imbalance FP64 | | | | | | | Tesla A100 | 9.7 | 1.55 | 9.7 1.55 √ó 8 50 | | AMD EPYC 7282 | 0.7 | 0.085 | 0.7 0.085 √ó 8 66 | Meaning we can do about 50 floating point operations per number accessed from main memory. Floating point operations are 'for free' when we work in memory bounded regimes. üëâ Requires to re think the numerical implementation and solution strategies Unfortunately, the cost of evaluating a first derivative ‚àÇA ‚àÇx using finite differences ```julia q ix D A ix 1 A ix dx ``` consists of 1 reads 1 write 2 √ó 8 16 Bytes transferred 1 fused addition and division 1 floating point operations üëâ assuming D, ‚àÇx are scalars, q and A are arrays of `Float64` read from main memory Performance that matters an example Not yet convinced? Let's have a look at an example. Let's assess how close from memory copy 1355 GB s we can get solving a 2D diffusion problem on an Nvidia Tesla A100 GPU. ‚àá‚ãÖ D ‚àá C \\frac ‚àÇC ‚àÇt Note You need a GPU for this to run it in this Notebook. If you don't have one, you can still follow the code and run it on VS Code Cluster. üëâ Let's test the performance using a simple scripts s1 perftest.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s1 perftest.jl script. Why to still bother with GPU computing in 2022 Because it is still challenging Why? Very few software uses it efficiently It requires to rethink the solving strategy as non local operations will kill the fun Slot 2 Hands on I Now it's time to get started. In the coming 2 hours, we will program a 2D transientdiffusion equation in a vectorised fashion in Julia. Then, we will turn it into a multi threaded loop version, and finally into a GPU code. The last part will consist of modifying the diffusion code to solve the channel flow in 2D with free surface and variable viscosity. Solving transient 2D diffusion on the CPU I Starting from the scripts start visu 2D.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts start visu 2D.jl script, create a new script `diffusion 2D.jl` where we will add diffusion physics \\frac ‚àÇC ‚àÇt ‚àá‚ãÖq~, q D~‚àáC ~, where D is the diffusion coefficient. Let's use a simple explicit forward Euler time stepping scheme and keep the same Gaussian distribution as initial condition. The diffusion coefficient D d 0 should be defined in all gird points such that it could be spatially variable in a later stage ```julia D d0 . ones ... ``` üí° If you struggle getting started, check out the scripts s2 diffusion 2D.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 diffusion 2D.jl script and try replacing the `??` by some more valid content. The solution script can be found at scripts solutions diffusion 2D sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions diffusion 2D sol.jl Solving transient 2D diffusion on the CPU II We will perform one additional step in order to make our code closer to be ready for kernel programming on GPUs. We will here isolate the lines that perform the actual computations, i.e., solve the PDE, and move those operations into functions. To avoid race conditions and keep correct synchronisation, we need to define 2 different compute functions, one for assigning the fluxes `update q ` and one for updating the values of C `update C ` . üí° Note the exclamation mark ` ` in the function name. This is a Julia convention if the function modifies the arguments passed to it. Create a new script, `diffusion 2D fun.jl`, where you will use the following template for the compute functions ```julia function update q Threads. threads for iz 1 size C, 2 for iy 1 size C, 1 if iy ?? && iz ?? qy iy, iz ?? end if iy ?? && iz ?? qz iy, iz ?? end end end return end ``` The `Threads. threads` in front of the outer loop allows for shared memory parallelisation on the CPU aka multi threading https docs.julialang.org en v1 manual multi threading if Julia is launched with more than one thread. Perform the similar tasks for `update C ` function. Also, replace the averaging helper functions my macros, and use macros as well to define helper functions for performing the derivative operations. üí° If you run out of ideas, check out the scripts s2 diffusion 2D fun.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 diffusion 2D fun.jl script and try replacing the `??` by some more valid content. The solution script can be found at scripts solutions diffusion 2D fun sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions diffusion 2D fun sol.jl Solving transient 2D diffusion on GPU Let's now move to GPU computing. Starting from the diffusion 2D fun.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 diffusion 2D fun.jl script you just finalised, we'll make it ready for GPU execution. In a new script `diffusion 2D cuda.jl`, we first need to modify the compute functions or kernels hereafter to replace the spatial loops by 2D vectorised indices that will parallelise the execution over many GPU threads ```julia function update q iy blockIdx .x 1 blockDim .x threadIdx .x iz blockIdx .y 1 blockDim .y threadIdx .y ?? return end ``` Then, in the ` numerics` section, we need to define some kernel launch parameters to specify the number of parallel workers to launch on the GPU ```julia nthreads 16, 16 nblocks cld. ny, nz , nthreads ``` You'll find more details about GPU kernel programming in the CUDA.jl https github.com JuliaGPU CUDA.jl documentation or on this course website https pde on gpu.vaw.ethz.ch . In the ` init` section, we will have now to specify that the arrays should be 'uploaded' to the GPU. The `C` init can be wrapped by `CuArray `. The fluxes and `D` array can be initialised on the GPU by adding `CUDA.` before `ones` or `zeros`. Also, one needs to specify the arithmetic precision as we want to perform double precision `Float64` computations, e.g., `CUDA.zeros Float64, nx, ny `. The kernel launch configuration and synchronisation need to be passed to the kernel launch call as following ```julia CUDA. sync cuda threads nthreads blocks nblocks update q ``` Finally, one needs to gather back on the host the `C` array for plotting, resulting in calling `Array C `. üí° If you run out of ideas, check out the scripts s2 diffusion 2D cuda.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 diffusion 2D cuda.jl script and try replacing the `??` by some more valid content. The solution script can be found at scripts solutions diffusion 2D cuda sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions diffusion 2D cuda sol.jl Channel flow in 2D The final step is to now turn the diffusion script into a channel flow script with non linear viscosity and a free surface. channel flow assets bcn model setup.png badge We consider the shear driven Stokes flow with power law rheology in a quasi 2D setup \\frac \\partial \\tau xy \\partial y \\frac \\partial\\tau xz \\partial z \\rho g\\sin\\alpha 0 \\tau ij 2\\eta \\varepsilon ij , \\quad \\varepsilon ij \\frac 1 2 \\left \\frac \\partial v i \\partial x j \\frac \\partial v j \\partial x i \\right \\eta k \\varepsilon \\mathrm II ^ n 1 Modify the diffusion script to turn it into a free surface channel flow. To this end, following changes are necessary the flux become the viscous stresses œÑ ij the quantity C becomes the out of plane velocity v x \\rho g\\sin\\alpha needs to be added as source term to the flux balance equation the diffusion coefficient D turns now into the nonlinear viscosity Œ∑ the force balance equation can be used to retrieve v x iteratively. For the iterative process can be designed as augmenting the force balance equation with a pseudo time step \\partial œÑ one can then use to reach a steady state \\frac \\partial \\tau xy \\partial y \\frac \\partial\\tau xz \\partial z \\rho g\\sin\\alpha \\frac \\partial v x \\partial œÑ ~. We now have a rule to update v x as function of the residual of the balance equation \\mathrm R v x \\mathrm R v x \\frac \\partial \\tau xy \\partial y \\frac \\partial\\tau xz \\partial z \\rho g\\sin\\alpha~, \\frac \\partial v x \\partial œÑ \\mathrm R v x~, such that \\partial v x \\partial v x \\partial œÑ \\mathrm R v x~. This simple iterations results in a Picrad like scheme simple but not ideal in terms of number of iterations to converge to a given tolerance. eyes This simple 'pseudo transient' scheme can be accelerated by using a second order scheme. This is on going research. Check out this lecture https pde on gpu.vaw.ethz.ch lecture3 solving elliptic pdes and related publication R√§ss et al., 2022 https gmd.copernicus.org articles 15 5757 2022 if curious about it. To proceed, start from the `diffusion 2D fun.jl` script from this previous step solving transient 2d diffusion on the cpu i and make sure the new physics is correctly implemented. In a second step, we will then port it to GPU kernel programming. Start a new script titled `channel flow 2D.jl` or start from the provided scripts s2 channel flow 2D.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 channel flow 2D.jl script. There, we introduce some new physics parameters ```julia physics non dimensional npow 1.0 3.0 sinŒ± sin œÄ 12 dimensionally independent ly, lz 1.0, 1.0 m k0 1.0 Pa s^npow œÅg 1.0 Pa m scales psc œÅg lz Œ∑sc psc k0 psc ^ 1.0 npow dimensionally dependent Œ∑reg 1e4 Œ∑sc ``` namely, power law exponent `npow`, slope angle `sinŒ±`, consistency factor `k0`, gravity acceleration `œÅg` and some scaling relations. Then we need some additional numerics parameters ```julia numerics œµtol 1e 6 Œ∑rel 5e 1 maxiter 20000max ny, nz ncheck 500max ny, nz ``` namely, the nonlinear tolerance `œµtol`, some relaxation for the viscosity continuation `Œ∑rel`, and a modification of the iteration parameter definition. In the ` init` section, rename `C` as `vx`, `D` as `Œ∑eff`, `qy` as `œÑxy` and `qz` as `œÑxz`. Also, no longer need to initialise `C` now `vx` with a Gaussian simply use zeros. From the equations, we see that the nonlinear viscosity \\eta is function of the second strain rate invariant …õ \\mathrm II at a given power. You can implement `eII` as a macro in the code ```julia macro eII esc sqrt. avz diff vx, dims 1 . dy .^ 2 . avy diff vx, dims 2 . dz .^ 2 end ``` Also, we now have to include the `err œµtol` condition in our `while` loop, such that ```julia while err œµtol && iter maxiter iteration loop end ``` For the boundary condition, enforce no slip condition at the bottom and open box at the top. This can be achieved as following ```julia vx , end . vx , end 1 vx 1, . vx 2, ``` Make finally sure to update the error checking and plotting as well ```julia if iter % ncheck 0 err maximum abs. diff œÑxy, dims 1 . dy . diff œÑxz, dims 2 . dz . œÅg sinŒ± lz psc push iters evo, iter nz push errs evo, err p1 heatmap yc, zc, vx' aspect ratio 1, xlabel 'y', ylabel 'z', title 'Vx', xlims ly 2, ly 2 , ylims 0, lz , c turbo, right margin 10mm p2 heatmap yv, zv, Œ∑eff' aspect ratio 1, xlabel 'y', ylabel 'z', title 'Œ∑eff', xlims ly 2, ly 2 , ylims 0, lz , c turbo, colorbar scale log10 p3 plot iters evo, errs evo xlabel 'niter nx', ylabel 'err', yscale log10, framestyle box, legend false, markershape circle display plot p1, p2, p3 size 1200, 400 , layout 1, 3 , bottom margin 10mm, left margin 10mm printf ' iter nz %.1f, err %1.3e\\n', iter nz, err end ``` Running the code should produce a figure similar to channel flow assets bcn channel flow.png üí° If you run out of ideas, check out the scripts s2 channel flow 2D.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 channel flow 2D.jl script and try replacing the `??` by some more valid content. The solution script can be found at scripts solutions channel flow 2D sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions channel flow 2D sol.jl In a second step, create now a GPU code titled `channel flow 2D cuda.jl` out of the channel flow script using kernel programming. Apply the same workflow as done for the diffusion codes. On the GPU, we now need 4 kernels to avoid sync issues and ensure correct execution ```julia update Œ∑eff update œÑ update v apply bc ``` üí° If you run out of ideas, check out the scripts s2 channel flow 2D cuda.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s2 channel flow 2D cuda.jl script and try replacing the `??` by some more valid content. The solution script can be found at scripts solutions channel flow 2D cuda sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions diffusion 2D cuda sol.jl Slot 3 Hands on II We will now port the single process codes we developed in the previous step to use distributed memory parallelisation using MPI. Multi CPU diffusion solver In a first step, we will port the CPU based diffusion solver to MPI. To exemplify the approach, let's have a look at the scripts s3 diffusion 2D mpi.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s3 diffusion 2D mpi.jl script, which implements non blocking task based asynchronous MPI halo exchange. We provide the following functions `cooperative wait`, `cooperative mpi wait`, `exchange halo ` and `gather ` but won't spend much time on what's going in there. In the code, we in addition need initialise MPI and prepare the Cartesian topology to use ```julia MPI.Init create MPI communicator comm MPI.Cart create MPI.COMM WORLD, dims me MPI.Comm rank comm neighbors ntuple Val length dims do idim MPI.Cart shift comm, idim 1, 1 end coords Tuple MPI.Cart coords comm ``` Then, we have to define the global number of grid points which takes into account 2 cells of overlap ```julia ny g, nz g ny 2 dims 1 2, nz 2 dims 2 2 ``` The initial condition needs also to be handled with care in order to define a Gaussian that would spread over different MPI processes ```julia init y0, z0 coords 1 ny 2 dy, coords 2 nz 2 dz yc y0 iy dy dy 2 ly 2 for iy 1 ny zc z0 iz dz dz 2 for iz 1 nz ``` Note that one now needs to correctly account for some shift in `y0, z0` as function of `coords`. Next MPI send and receive buffers need to be initialised ```julia MPI buffers send bufs zeros nz for side in 1 2 , zeros ny for side in 1 2 recv bufs deepcopy send bufs ``` In the time loop, we need to call the exchange halo function right after the two compute kernels to update the internal boundary conditions ```julia exchange halo C, neighbors, send bufs, recv bufs, comm ``` For visualisation, we can use the provided `gather ` function in order to collect all sub arrays into a single global array the process 0 `me 0` can save to disk. ```julia C g me 0 ? zeros dims 1 ny 2 , dims 2 nz 2 nothing MPI.Barrier comm gather C g, C 2 end 1, 2 end 1 , comm ``` As last, one needs to finalise MPI calling `MPI.Finalize `. To debug, you can run the MPI script from within the Julia REPL for this you need to comment `MPI.Init ` and `MPI.Finalize ` from the code as you are only allowed to call them once per Julia session. If you then want to run the diffusion MPI script on multiple processors, you can do so as following ```sh mpirun np 4 mca btl openib warn default gid prefix 0 julia project diffusion 2D mpi.jl ``` If this runs, you have now a Julia code the runs on distributed memory parallelisation üí° Additional resources and exercises to familiarise with MPI halo exchange concepts for staggered grids can be found in this course material https pde on gpu.vaw.ethz.ch lecture8 distributed computing in julia . Multi GPU diffusion solver The cool thing with Julia is that porting the previous CPU based code to GPU is fairly straight forward. The only thing to do is to make arrays and send receive buffers GPU arrays vectors. You can either start from the previous CPU MPI code and add the GPU specific bits, or start from the GPU diffusion code and add the MPI bits. üí° Note that if you are running out of ideas, you can always look up the solution code scripts solutions diffusion 2D mpi cuda sol.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts solutions diffusion 2D mpi cuda sol.jl Multi GPU channel flow Now that you made it for the Julia GPU MPI implementation for the diffusion equation in 2D, you could implement the channel flow with MPI by analogy. Slot 4 OPTION 1 AD tools in Julia Automatic differentiation https en.wikipedia.org wiki Automatic differentiation AD allows evaluating the gradients of functions specified by code. Using AD, the partial derivatives are evaluated by repeatedly applying the chain rule of differentiation to the sequence of elementary arithmetic operations constituting a computer program. üí° Many constructs in computer programs aren't differentiable, for example, I O calls or system calls. AD tools must handle such cases. Automatic differentiation is a key ingredient of differentiable programming https en.wikipedia.org wiki Differentiable programming , a programming paradigm enabling gradient based optimisation of the parameters of an arbitrary computer program. Julia has a rich support for differential programming. With the power of tools like Enzyme.jl https enzyme.mit.edu julia stable it is possible to automatically compute the derivatives of arbitrary Julia code, including the code targeting GPUs. VJP calculations One of the main building blocks in many optimization algorithms involves computing the vector jacobian product JVP . AD tools simplify evaluating JVPs by generating the code automatically given the target function. Let's familiarise with Enzyme.jl https enzyme.mit.edu julia stable , the Julia package for performing AD. üí° There are many other Julia packages for performing AD, e.g., Zygote.jl https fluxml.ai Zygote.jl stable . In this tutorial, we use Enzyme as it supports some features currently missing in other packages, e.g., differentiating mutating functions and GPU kernels. Let's start with a simple example ```julia julia using Enzyme julia f œâ,x sin œâ x f generic function with 1 method julia ‚àáf œâ,x Enzyme.autodiff Reverse,f,Active,Const œâ ,Active x 1 2 ‚àáf generic function with 1 method julia assert ‚àáf œÄ,1.0 ‚âà œÄ cos œÄ ``` In this line `‚àáf x Enzyme.autodiff Reverse,f,Active,Active x 1 1 `, we call `Enzyme.autodiff` function, which computes the partial derivatives. We pass `Reverse` as a first argument, which means that we use the reverse mode of accumulation see below . We mark the arguments as either `Const` or `Active` to specify which partial derivatives are computed. Let's make more advanced example, differentiating the vector valued function. We'll use the 1D residual function for the steady state diffusion ```julia function residual R,C,dc,dx for ix in 2 length R 1 R ix dc C ix 1 2.0 C ix C ix 1 dx^2 end end ``` This function mutates it's argument `R`, storing the result of computing the residual in place. Also, this function is vector valued, and returns a vector as well. Information about partial derivatives of such functions is described by its Jacobian matrix https en.wikipedia.org wiki Jacobian matrix and determinant . In reverse mode https enzyme.mit.edu julia stable generated autodiff Reverse mode of derivative accumulation, also known as backpropagation , one call to Enzyme computes the product of transposed Jacobian matrix and a vector, known as VJP vector Jacobian product . To propagate the gradient information, extra storage is needed to store the vector, and the computed derivatives. ```julia function grad residual RÃÑ,CÃÑ,R,C,dc,dx Enzyme.autodiff Reverse,residual ,Duplicated R,RÃÑ ,Duplicated C,CÃÑ ,Const dc ,Const dx return end ``` Here, we introduced the new parameter activity type, `Duplicated`. The first element of `Duplicated` argument takes the value of a variable, and the second the adjoint . Often the residual computation is split in several functions, or kernels. In that case, the simplest solution is to manually apply the chain rule better alternative involves defining custom rules https enzyme.mit.edu julia stable generated custom rule , which is out of scope for this tutorial \\left \\frac \\partial R q C \\partial C \\right ^\\mathrm T \\left \\frac \\partial R q \\partial q \\frac \\partial q C \\partial C \\right ^\\mathrm T \\left \\frac \\partial q C \\partial C \\right ^\\mathrm T \\left \\frac \\partial R q \\partial q \\right ^\\mathrm T Starting from the scripts s4 diffusion 1D enzyme.jl scripts s4 diffusion 1D enzyme.jl , implement the multiple kernels version of residual evaluation, by replacing the ?? symbols with some meaningful content. If the residual function is a GPU kernel, the syntax is a little bit different ```julia function grad residual RÃÑ,CÃÑ,R,C,dc,dx Enzyme.autodiff deferred Reverse,residual ,Duplicated R,RÃÑ ,Duplicated C,CÃÑ ,Const dc ,Const dx return end ``` üí° Note that we call `autodiff deferred` instead of `autodiff`. Try to port the 1D diffusion code with Enzyme to GPU. Use the scripts s4 diffusion 1D enzyme cuda.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s4 diffusion 1D enzyme cuda.jl as a starting point. Apply the knowledge to differentiate the residual of the 2D channel flow problem. Use the scripts s4 channel flow 2D enzyme cuda.jl https github.com PTsolvers Galileo23 MC1 GPU blob main scripts s4 channel flow 2D enzyme cuda.jl as a starting point. Advanced Towards sensitivity kernels and adjoint solutions Now, as we know how to compute VJPs using Enzyme, it's time to use the knowledge to compute the sensitivity of the solution, i.e., the velocity, to the steady channel flow problem with respect to changes in effective viscosity. To quantify the sensitivity, we need to define some metric. We will use the sensitivity kernel definition from Reuber 2021 https link.springer.com article 10.1007 s13137 021 00186 y , which defines the sensitivity kernel as the derivative of the following function with respect to the parameter of interest J v \\int v To evaluate the derivative, we can use the chain rule \\frac \\mathrm d J\\left v Œ∑ \\right \\mathrm d Œ∑ \\frac \\partial J\\left v Œ∑ \\right \\partial v \\frac \\mathrm d v \\mathrm d \\eta The tricky term to evaluate is the derivative of the solution to the problem w.r.t. the solution, \\frac \\mathrm d v \\mathrm d \\eta . To compute this derivative, we use the fact that at the steady state the residual of the right hand side of the system of the equations reaches it's minimum. Taking the derivative of the residual with respect to the viscosity \\eta and using the chain rule again, we obtain \\frac \\mathrm d R \\mathrm d \\eta \\frac \\partial R \\partial v \\frac \\mathrm d v \\mathrm d \\eta \\frac \\partial R \\partial\\eta 0 Solving for \\frac \\mathrm d v \\mathrm d \\eta and plugging into the sensitivity kernel, we obtain \\frac \\mathrm d J\\left v Œ∑ \\right \\mathrm d Œ∑ \\frac \\partial J\\left v Œ∑ \\right \\partial v \\left \\frac \\partial R \\partial v \\right ^ 1 \\frac \\partial R \\partial\\eta Directly inverting the matrix \\frac \\partial R \\partial v is prohibitibvely expensive, but instead we can use the temporary variable, called the adjoint state \\left \\frac \\partial R \\partial v \\right ^\\mathrm T \\Psi \\frac \\partial J \\partial v \\frac \\mathrm d J \\mathrm d \\eta \\Psi^\\mathrm T \\frac \\partial R \\partial\\eta In this way, we can compute the point wise sensitivity in only one additional linear solve. To solve the system of equations \\left \\frac \\partial R \\partial v \\right ^\\mathrm T \\Psi \\frac \\partial J \\partial v , we can use the same pseudo transient method that we employed for the forward problem \\frac \\partial\\Psi \\partial\\tau \\left \\frac \\partial R \\partial v \\right ^\\mathrm T \\Psi \\frac \\partial J \\partial v To integrate this system in pseudo time, we need to iteratively apply the transposed jacobian to the adjoint state variable vector. And this is exactly what is computed using the AD Extend the 2D channel flow example with the VJP calculation with an iterative loop to update the adjoint variable `vÃÑ` using the same approach as the original problem. üí° Note that in this particular case, \\frac \\partial J \\partial v 1 \" "},{"url":"channel_flow_2D/","title":"Channel Flow 2D","tags":["bcn"],"text":" A Pluto.jl notebook v0.19.25 frontmatter chapter \"2\" Authors \"Ludovic R√§ss, Ivan Utkin\" section \"3\" order \"3\" title \"Channel Flow 2D\" tags \"bcn\" layout \"layout.jlhtml\" description \"2D Channel Flow example of the BCN MasterClass 2023\" using Markdown using InteractiveUtils begin using Plots, Printf using Plots.PlotMeasures end begin views av A 0.5 . A 1 end 1 . A 2 end views avy A 0.5 . A 1 end 1, . A 2 end, views avz A 0.5 . A , 1 end 1 . A , 2 end views av4 A 0.25 . A 1 end 1, 1 end 1 . A 1 end 1, 2 end . A 2 end, 1 end 1 . A 2 end, 2 end views bc2 A A 1, end , . A 2, end 1 , A , 1, end . A , 2, end 1 macro eII esc sqrt. avz diff vx, dims 1 . dy .^ 2 . avy diff vx, dims 2 . dz .^ 2 end end views function main physics non dimensional npow 1.0 3.0 sinŒ± sin œÄ 12 dimensionally independent ly, lz 1.0, 1.0 m k0 1.0 Pa s^npow œÅg 1.0 Pa m scales psc œÅg lz Œ∑sc psc k0 psc ^ 1.0 npow dimensionally dependent Œ∑reg 1e4 Œ∑sc numerics nz 64 ny ceil Int, nz ly lz cfl 1 4.1 œµtol 1e 6 Œ∑rel 5e 1 maxiter 20000max ny, nz ncheck 500max ny, nz preprocessing dy, dz ly ny, lz nz yc, zc LinRange ly 2 dy 2, ly 2 dy 2, ny , LinRange dz 2, lz dz 2, nz yv, zv av yc , av zc dœÑ cfl min dy, dz ^2 init ?? zeros ny, nz ?? zeros ny 1, nz 1 ?? zeros ny 1, nz 2 ?? zeros ny 2, nz 1 action iters evo Float64 errs evo Float64 err 2œµtol iter 1 while err œµtol && iter maxiter Œ∑eff . Œ∑eff . 1.0 Œ∑rel . Œ∑rel . 1.0 . ?? . 1.0 Œ∑reg œÑxy . ?? œÑxz . ?? vx 2 end 1, 2 end 1 . ?? vx , end . vx , end 1 vx 1, . vx 2, if iter % ncheck 0 err maximum abs. diff œÑxy, dims 1 . dy . diff œÑxz, dims 2 . dz . œÅg sinŒ± lz psc push iters evo, iter nz push errs evo, err p1 heatmap yc, zc, vx' aspect ratio 1, xlabel \"y\", ylabel \"z\", title \"Vx\", xlims ly 2, ly 2 , ylims 0, lz , c turbo, right margin 10mm p2 heatmap yv, zv, Œ∑eff' aspect ratio 1, xlabel \"y\", ylabel \"z\", title \"Œ∑eff\", xlims ly 2, ly 2 , ylims 0, lz , c turbo, colorbar scale log10 p3 plot iters evo, errs evo xlabel \"niter nx\", ylabel \"err\", yscale log10, framestyle box, legend false, markershape circle display plot p1, p2, p3 size 1200, 400 , layout 1, 3 , bottom margin 10mm, left margin 10mm printf \" iter nz %.1f, err %1.3e\\n\", iter nz, err end iter 1 end return end main end "},{"url":"cheatsheets/","title":"Cheatsheets","tags":["welcome"],"text":"Cheatsheets Getting Started with Julia - live . Fastrack to Julia  cheatsheet. MATLAB-Julia-Python comparative cheatsheet  by  QuantEcon group Plots.jl cheatsheet"},{"url":".","title":"index","tags":["homepage"],"text":""},{"url":"installation_Pluto/","title":"Introduction and Installation","tags":["welcome"],"text":" A Pluto.jl notebook v0.19.25 frontmatter title \"Introduction and Installation\" tags \"welcome\" license \"MIT\" description \"This is the first step towards programming in Julia\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils md\" Introduction to Julia by AG Geophysik at the University of Mainz\" md\" DISCLAIMER This webpage is a work in progress and if you got recommendations, feel free to email us mailto paellig uni mainz.de \\ Furthermore, this Introduction was inspired by the MIT Computational Thinking class and Marcel Thielmanns's course on the Geophysical Model Generator Uni Bayreuth\" md\" 1. Introduction\" md\"The Julia scientific programming language is fast, completely open source and comes with a nice package manager. It works on essentially all systems and has an extremely active user base. Programming in Julia is fairly easy and comparable to programming in MATLAB. If you have experience in MATLAB programming, transitioning to Julia should be relatively smooth.\" md\"In this course you will learn how to use Julia from simple coding exercises to get familiar with the structure of Julia to interactive geodynamical programming using LaMeM and other packages developed by the AG Geophysik at the University of Mainz\" md\" 1.1 Installation of Julia\" md\" Step 1 Download Julia Go to https julialang.org downloads https julialang.org downloads and download the current stable release, using the correct version for your operating system Linux x86, Mac, Windows, etc . Additionally, we rely on Microsoft Visual Studio Code https code.visualstudio.com as a debugger and visualisation tool. After downloading both Julia and VS Code, make sure to also install the Julia Language extension within VS Code. See here https code.visualstudio.com docs languages julia for help when setting it up. Step 2 Run Julia After installing, make sure that you can run Julia . On some systems, this means searching for the program installed on your computer in others, it means running the command `julia` in a terminal. Make sure that you can execute `1 1` Step 3 Install Pluto https github.com fonsp Pluto.jl Next we will install the Pluto https github.com fonsp Pluto.jl , the notebook environment that we will be using during the course. Pluto is a Julia programming environment designed for interactivity and quick experiments. Open the Julia REPL . This is the command line interface to Julia, similar to the previous screenshot. Here you type Julia commands , and when you press ENTER, it runs, and you see the result. To install Pluto, we want to run a package manager command . To switch from Julia mode to Pkg mode, type ` ` closing square bracket at the `julia ` prompt. ```julia julia v1.9 pkg add Pluto ``` This might take a couple minutes to download all the dependencies. If you do not want to continue to work on the notebook, you can close the Terminal now. Step 4 Run Pluto on a modern Browser Viewing Pluto notebooks require a modern browser. The notebooks work best on Mozilla Firefox or Google Chrome, however Safari is also operational. Step 5 Starting Pluto and running the interactive notebooks Before we are able to run the notebooks, we need to open the Julia REPL if you closed it after step 3 and load Pluto and type PLuto.run . ```julia julia using Pluto julia Pluto.run ``` The terminal will tell you the URL e.g. http localhost 1234 and open a browser window on its own. \" "},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict \"main\" \"Welcome\" collections \"welcome\" .pages, \"Getting familiar with Julia\" collections \"Basics\" .pages, \"GeophysicalModelGenerator.jl\" collections \"GMG\" .pages, \"Workshop BCN\" collections \"bcn\" .pages, \"SCALES\" collections \"scales\" .pages, , "},{"url":"structure/","title":"structure","tags":[],"text":""}]